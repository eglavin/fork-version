interface Commit {
	title: string;
	body: string;
	hash: string;
	date: string;
	name: string;
	email: string;
}

/**
 * Parse a commit log in the following format:
 * ```txt
 * refactor: add test file\n\n4ef2c86d393a9660aa9f753144256b1f200c16bd\n2024-12-22T17:36:50Z\nFork Version\nfork-version@example.com\n
 * ```
 *
 * This output can be generated by running the following command:
 * ```sh
 * git log --format="%s%n%b%n%H%n%aI%n%aN%n%aE%n"
 * ```
 * @see {@link https://git-scm.com/docs/pretty-formats|Git Pretty Format Documentation}
 */
export function parseCommit(commit: string): Commit {
	const parsedCommit: Commit = {
		title: "",
		body: "",
		hash: "",
		date: "",
		name: "",
		email: "",
	};

	// Split the commit log into separate parts on the new line character.
	const parts = commit.split("\n");

	if (parts.length <= 6) {
		throw new Error("Invalid commit format", {
			cause: "Commit doesn't contain enough parts",
		});
	}

	// Remove the last empty line
	const finalNewLine = parts.pop();
	if (finalNewLine !== "") {
		throw new Error("Invalid commit format", {
			cause: "Commit doesn't end with a new line character",
		});
	}

	const email = parts.pop();
	if (email) {
		parsedCommit.email = email.trim();
	}

	const name = parts.pop();
	if (name) {
		parsedCommit.name = name.trim();
	}

	const date = parts.pop();
	if (date) {
		parsedCommit.date = date.trim();

		// Date is one only fields we can properly validate, so we'll check it now to ensure its in the correct place.
		if (Number.isNaN(Date.parse(parsedCommit.date))) {
			throw new Error("Invalid commit format", {
				cause: "Date is not a valid date string",
			});
		}
	}

	const hash = parts.pop();
	if (hash) {
		parsedCommit.hash = hash.trim();
	}

	const title = parts.shift();
	if (title) {
		parsedCommit.title = title.trim();
	}

	// The rest of the parts are the body of the commit
	parsedCommit.body = parts.join("\n").trim();

	return parsedCommit;
}
