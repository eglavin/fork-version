interface Commit {
	title: string;
	body: string;
	hash: string;
	date: string;
	name: string;
	email: string;
}

/**
 * Parse a commit log in the following format:
 * ```txt
 * refactor: add test file\n\n4ef2c86d393a9660aa9f753144256b1f200c16bd\n2024-12-22T17:36:50Z\nFork Version\nfork-version@example.com\n
 * ```
 *
 * This output can be generated by running the following command:
 * ```sh
 * git log --format="%s%n%b%n%H%n%aI%n%aN%n%aE%n"
 * ```
 * @see {@link https://git-scm.com/docs/pretty-formats|Git Pretty Format Documentation}
 */
export function parseRawCommit(rawCommit: string): Commit {
	const parsedCommit: Commit = {
		title: "",
		body: "",
		hash: "",
		date: "",
		name: "",
		email: "",
	};

	// Split commit into separate parts on new line characters
	const parts = rawCommit.trim().split(/\r?\n/);

	if (parts.length <= 5) {
		throw new Error("Invalid commit format", { cause: "Commit doesn't contain enough parts" });
	}

	// Walk backwards through the parts array to extract
	// the data in the expected order:
	// - author email
	// - author name
	// - author date
	// - hash
	// Take the title from the front of the array
	// and the rest of the content is the body of the commit

	const email = parts.pop();
	if (email) {
		parsedCommit.email = email.trim();
	}

	const name = parts.pop();
	if (name) {
		parsedCommit.name = name.trim();
	}

	const date = parts.pop();
	if (date) {
		parsedCommit.date = date.trim();

		// Date is one only fields we can properly validate, so we'll check it now to ensure its in the correct place.
		if (Number.isNaN(Date.parse(parsedCommit.date))) {
			throw new Error("Invalid commit format", { cause: "Unable to parse commit date" });
		}
	}

	const hash = parts.pop();
	if (hash) {
		parsedCommit.hash = hash.trim();
	}

	const title = parts.shift();
	if (title) {
		parsedCommit.title = title.trim();
	}

	// The rest of the parts are the body of the commit
	parsedCommit.body = parts.join("\n").trim();

	return parsedCommit;
}
